%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Snakefiles as Python-Code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
    \frametitle{Outline}
    \begin{columns}[t]
        \begin{column}{.5\textwidth}
            \tableofcontents[sections={1-9},currentsection]
        \end{column}
        \begin{column}{.5\textwidth}
            \tableofcontents[sections={10-18},currentsection]
        \end{column}
    \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python Code in Snakefiles}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{What is this about?}
   \question[Questions]{\begin{itemize}
                         \item How can I automatically manage dependencies and outputs?
                         \item How can I use Python code to add features to my pipeline?
                        \end{itemize}
                       }
   \docs[Objectives]{\begin{enumerate}
                      \item Use variables, functions, and imports in a Snakefile. 
                      \item Learn to use the \texttt{run} action to execute Python code as an action.
                     \end{enumerate}}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The Issues we still have}
  Our workflow still has repeated content, e.\,g. the names of output files/dependencies. Our \altverb{zipf_test} rule is extremely clunky. What happens if we want to analyse \texttt{books/sierra.txt} as well? We’d have to update everything!
  \begin{lstlisting}[language=Python,style=Python, basicstyle=\tiny]
rule zipf_test:
    input:  , 'abyss.dat',
            'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python 'scripts/zipf_test.py' {input} > {output}'
  \end{lstlisting}
  You probably noticed: all of our rules are using Python strings! Other data structures work too — let’s try a list:
  \begin{lstlisting}[language=Python,style=Python, basicstyle=\tiny]
rule zipf_test:
    input:
        books=['abyss.dat', 'last.dat', 'isles.dat']
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py {input.books} > {output}'
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Putting the last change to action!}
  This illustrates a key feature of \texttt{Snakemake}. Snakefiles are just Python code. We can make our list into a variable to demonstrate this. Let’s create the variable \altverb{DATS} and use it in our \altverb{zipf_test} and dats rules.
  \task{Test the following changes!}

  \begin{lstlisting}[language=Python,style=Python]
DATS=['abyss.dat', 'last.dat', 'isles.dat']

rule zipf_test:
    input:
        books=DATS
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py'
            ' {input.books} > {output}'
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Supported Functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Using functions in Snakefiles}
  In our example here, we only have 4 books. But what if we had 700 books to be processed? \newline
  Luckily, \texttt{Snakemake} and Python provide helper functions!
  \task{Python and follow along!}
  \begin{lstlisting}[language=Python,style=Python]
from snakemake.io import expand, glob_wildcards
  \end{lstlisting}
  The first function we’ll use is \altverb{expand()}. \altverb{expand()} is used frequently, to expand a \texttt{snakemake} wildcard(s) into a set of filenames:
  \begin{lstlisting}[language=Python,style=Python]
>>> expand('folder/{wildcard1}_{wildcard2}.txt',
...        wildcard1=['a', 'b', 'c'],
...        wildcard2=[1, 2, 3])
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Using functions in Snakefiles II}
  \question{What is the result?}
  \pause
  \hint[Answer:]{Every permutation of \altverb{wildcard1} and \altverb{wildcard2}!}
  \pause
  Let us try \altverb{glob_wildcards()}, now:
  \begin{lstlisting}[language=Python,style=Python]
glob_wildcards('../books/{example}.txt')
  \end{lstlisting}
  \pause
  Wow! So, easy!
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python Code as Actions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\Interlude{Meeting the \texttt{run} Action}}
  \vspace{-0.5em}
  In order to run Python code in \texttt{Snakemake}, we have to replace the \altverb{shell:} action by a \altverb{run:} action:\vspace{-0.5em}
  \task{We \emph{could} have the following to our \altverb{Snakefile}:}\vspace{-0.5em}
  \begin{lstlisting}[language=Python,style=Python, basicstyle=\footnotesize]
# at the top of the file
import glob

# add this wherever
rule print_book_names:
    run:
        print('These are all the book names:')
        for book in glob.glob('../books/*.txt'):
            print(book)

  \end{lstlisting}\vspace{-0.5em}
  \pause\footnotesize
  \hint[The idea:]{This allows for Python snippets in rules without saving Python files, e.\,g. for short data mangling.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Snakemake and external Scripts}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\texttt{Snakemake} Specials for Python}
  Consider this call:
  \begin{lstlisting}[language=Python,style=Python]
shell:  'python scripts/wordcount.py'
        ' -i {input} -o {output}'
  \end{lstlisting}
  \question{Isn't this rather tedious, considering that \texttt{Snakemake} is writting in Python?}
\end{frame}

\begingroup
\setbeamertemplate{footline}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\texttt{Snakemake}'s features for external Scripts}
  In addition to the \altverb{shell} and \altverb{run} directives, \texttt{Snakemake} offers a \altverb{script} directive, too:
  \begin{lstlisting}[language=Python,style=Python]
rule NAME:
    input:
        "path/to/inputfile",
        "path/to/other/inputfile"
    output:
        "path/to/outputfile",
        "path/to/another/outputfile"
    script:
        "scripts/script.py"
  \end{lstlisting}
  This lets you use (in \altverb{script.py}):
  \begin{lstlisting}[language=Python,style=Python]
def do_something(data_path, out_path):
    # python code

do_something(snakemake.input[0], snakemake.output[0])
  \end{lstlisting}
\end{frame}
\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\Interlude{The same feature is offered for R}}
  \begin{lstlisting}[language=R,style=R]
do_something <- function(data_path, output_path) {
    # R code
}

do_something(snakemake@input[[1]], snakemake@output[[1]])
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\Interlude{Debugging external Scripts}}
  \begin{exampleblock}{Debugging Python Scripts}
  To debug Python scripts, you can invoke \texttt{Snakemake} with
  \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake --debug
  \end{lstlisting}
  As always in Python, you may use \altverb{print()} and \altverb{logging()} functions which may write to a log file during the run to check whether the script behaves as expected.
  \end{exampleblock}
  \pause
  \begin{exampleblock}{Debugging R Scripts}
  To debug R scripts, you can save the workspace with \altverb{save.image()}, and invoke R after \texttt{Snakemake} has terminated. 
  \end{exampleblock}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\HandsOn{Using \texttt{Snakemake}'s features in scripts}}
  \footnotesize{Remember:}
  \begin{lstlisting}[language=Python,style=Python, basicstyle=\footnotesize]
def do_something(data_path, out_path):
    # python code

do_something(snakemake.input[0], snakemake.output[0])
  \end{lstlisting}
  \footnotesize{and the \altverb{script} directive option in \texttt{Snakefile}s. }
  \task{\footnotesize Please rewrite the \texttt{wordcount.py} script and the \texttt{Snakefile} to use this feature.}
  \hint{\small Erase the argument parsing code (bottom of the file) and the arguments of the function (very last line) to use the\newline \texttt{snakemake.input}/\texttt{snakemake.output} arguments.}
  \vfill
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The Solution - so far}
  Our \altverb{count_words} rules should merely be:
  \begin{lstlisting}[language=Python,style=Python]
rule count_words:
    input:  '../books/{file}.txt'
    output: '{file}.dat'
    script:  'scripts/wordcount.py'
  \end{lstlisting}
  Our last lines of the \texttt{wordcount.py} became:
  \begin{lstlisting}[language=Python,style=Python]
# omitting the entire code, except for the call to the
# word_count()-function:
if __name__ == '__main__':
    word_count(snakemake.input[0], snakemake.output[0])
  \end{lstlisting}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The Solution - some Explanation}
  \question{Why \texttt{[0]} indices?}
  \vfill
  \docs{\texttt{snakemake.input} is of type \newline ``\texttt{<class 'snakemake.io.InputFiles'>}'' \newline (same for \texttt{snakemake.output})}
  \vfill
\end{frame}





