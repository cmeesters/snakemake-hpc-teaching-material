%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Decorating the Workflow}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Better In-/Output}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{What is this about?}
   \question[Questions]{How can I abbreviate the rules in my workflow?}
   \docs[Objectives]{\begin{enumerate}
                      \item  Use snakemake wildcards to simplify our rules.
                      \item Output files are a product not only of input files but of the scripts or code that created the output files.
                     \end{enumerate}}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
Our little exercise should produce this Workflow:
     \begin{lstlisting}[language=Python,style=Python, basicstyle=\tiny]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' abyss.dat isles.dat last.dat > results.txt'
    
rule dats:
     input:
         'isles.dat',
         'abyss.dat',
         'last.dat'

# delete everything so we can re-run things
rule clean:
    shell: 'rm -f *.dat results.txt'

# count words in one of our "books"
rule count_words:
    input:    'books/isles.txt'
    output:   'isles.dat'
    shell:    'python scripts/wordcount.py'
              ' -i books/isles.txt -o isles.dat'

rule count_words_abyss:
    input:    'books/abyss.txt'
    output:   'abyss.dat'
    shell:    'python scripts/wordcount.py' 
              ' -i books/abyss.txt -o abyss.dat'
              
rule count_words_last:
    input:    'books/last.txt'
    output:   'last.dat'
    shell:    'python scripts/wordcount.py'
              ' -i books/last.txt -o last.dat'
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Rule number One: Don't repeat Yourself!}

Our Snakefile has a lot of duplication. For example, the names of text files and data files are repeated in many places throughout the Snakefile. Snakefiles are a form of code and, in any code, repeated code can lead to problems (e.g. we rename a data file in one part of the Snakefile but forget to rename it elsewhere).
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wildcards}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{output\}} Wildcard}
  Taking our last rule
  \begin{lstlisting}[language=Python,style=Python]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' abyss.dat isles.dat last.dat > results.txt'
  \end{lstlisting}
  We can replace the result name first with the wildcard \texttt{\{output\}}:
  \begin{lstlisting}[language=Python,style=Python]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' abyss.dat isles.dat last.dat > {output}'
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{input\}} Wildcard}
  Likewise, we may choose to replace our inputs:
  \begin{lstlisting}[language=Python,style=Python]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' {input} > {output}'
  \end{lstlisting}
  Here, \texttt{\{input\}} will contain the entire list of inputs!
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{input\}} Wildcard - II}
  We have learned that
  \begin{lstlisting}[language=Python,style=Python]
rule <rulename>:
  input: <file1>, <file2>, ... <file_n>
  \end{lstlisting}
  translates to a list which we can acess as
  \begin{lstlisting}[language=Python,style=Python]
  shell: 'cmd {input}'
  \end{lstlisting}
  As it is a list, we can access individual items by index, too. E.\,g.:
  \begin{lstlisting}[language=Python,style=Python]
  shell: 'cmd --reference {input[0} -i {input[1]}'
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{input\}} Wildcard - III}
  So, \texttt{\{input\}}, can be a single item, a list (accessible by index) or named. For example:
  \begin{lstlisting}[language=Python,style=Python]
rule <rulename>:
  input:
    reference: <path to reference>
    forward:   <path to forward reads>
    reverse:   <path to reverse reads>
  # minimap2 is just an example
  shell: 'minimap2 {reference} {forward}' 
         ' {reverse} > {output}'
  \end{lstlisting}
  \pause
  \texttt{\{output\}} follows the same rules, so for both the options are:
  \begin{itemize}
   \item single item
   \item list (accessible by index)
   \item named access
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  We \emph{could} write:
  \begin{lstlisting}[language=Python,style=Python]
rule count_words:
    input:
        wc='scripts/wordcount.py',
        book='books/{file}.txt'
    output: '{file}.dat'
    shell:  'python {input.wc} {input.book} {output}'
  \end{lstlisting}
  \explanation{\texttt{\{file\}} is another arbitrary wildcard, that we can use as a placeholder for any generic book to analyse. Note that we don’t have to use {file} as the name of our wildcard — it can be anything we want! Condition: Only available for \texttt{input} and \texttt{output}, not actions!}
  \begin{block}{This rule can be interpreted as:}
``In order to build a file named \texttt{something.dat} (the output) find a file named \texttt{books/something.txt} (the input) and run \texttt{wordcount.py input output}.''
  \end{block}
\end{frame}
