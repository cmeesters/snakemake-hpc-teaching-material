%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametizing your Workflow}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
    \frametitle{Outline}
    \begin{columns}[t]
        \begin{column}{.5\textwidth}
            \tableofcontents[sections={1-9},currentsection]
        \end{column}
        \begin{column}{.5\textwidth}
            \tableofcontents[sections={10-18},currentsection]
        \end{column}
    \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{What is this about?}
   \question[Questions]{\begin{itemize}
                         \item How do we add execution parameters?
                         \item How do we tune scientific parameters?
                        \end{itemize}
                       }
   \docs[Objectives]{\begin{enumerate} 
                      \item Learn to use parameters relevant for the batch systems.
                      \item Learn how to tune \texttt{Snakemake} on the command line.
                      \item Learn how to tune \texttt{Snakemake} with configuration files.
                     \end{enumerate}}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Command Line vs. Configuration File}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \docs{\texttt{Snakemake} has an extensive command line interface (CLI). \emph{Everything} can be configured on the command line. In addition (almost) everything can be specified in a configuration file.}
  \pause
  \begin{exampleblock}{Which parameter goes where? Some rules of thumb:}
    \begin{columns}[t]
      \begin{column}{0.5\textwidth}
        The CLI:
        \begin{itemize}
         \item frequently changing parameters
         \item short parameters
         \item default parameters
        \end{itemize}
      \end{column}
      \begin{column}{0.5\textwidth}
        The Config File:
        \begin{itemize}
         \item non-volantile parameters specific to your analysis (those which merit mentioning in paper should always go into a file)
         \item long parameters
         \item otherwise workflow specific parameters
        \end{itemize}
      \end{column}
    \end{columns}
  \end{exampleblock}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Command Line}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Executor Selection}
  \texttt{Snakemake} lets you select various executors. Not happy with \mogon? Take another cluster or \lhref{https://snakemake.readthedocs.io/en/stable/executor_tutorial/tutorial.html}{Google Lifescience, Tibanna, Kubernetes, \ldots} \newline
  We may happily select the most prominent HPC batch system, the one running on \mogon, too:
  \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake --slurm
  \end{lstlisting}
  Now, \emph{every} rule will submit its jobs as HPC compute jobs.
  \hint{We will learn how to avoid this, soon-ish.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Default Resources for \texttt{SLURM}}
  Without specifying our SLURM-account and a (default) partition, submitting batch jobs will fail. \texttt{Snakemake} allows to define so-called default resources (using \altverb{--default-resources}). With them our minimal command line becomes:
  \begin{lstlisting}[language=Bash, style=Shell, breaklines=true]
$ snakemake --slurm \
> --default-resources slurm_account=m2_jgu-ngstraining \
>                     slurm_partition=smp
  \end{lstlisting}
  \hint{Please notice the missing quotation marks! All arguments belong to one parameter.}
  \docs{We wrote \texttt{slurm\_...} to distinguish from other non-SLURM accounts and similar stuff.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The Beauty of Clusters}
  A HPC cluster:
  \begin{itemize}
   \item offers great resources
   \item may hold jobs pending until resources are available!
  \end{itemize}
  \pause
  \texttt{Snakemake} of a semaphore to throttle resource usage, called \altverb{--jobs/-j}. We can now write \altverb{-j unlimited} in place for \altverb{--cores 1}. Let us try
  \begin{lstlisting}[language=Bash, style=Shell, basicstyle=\footnotesize]
$ snakemake --slurm \
> --default-resources \ 
>   slurm_account=m2_jgu-ngstraining \
>   slurm_partition=smp
> -j unlimited
  \end{lstlisting}
  together.
  \hint{You might want to invoke the \texttt{clean}-rule, first.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\texttt{SLURM} supporting Features of \texttt{Snakemake}}
  \texttt{Snakemake} will
  \begin{itemize}[<+->]
   \item hold track of your job status (frequency of checks can be adjusted)
   \item cancel your jobs, when itself is stopped
   \item track resource consumption (generated with \altverb{--report [FILE]})
   \item with \altverb{-j unlimited} we allow for an unlimited jumber of spawned jobs!
  \end{itemize}
  \pause
  \warning{Unlimited number of jobs may yield in I/O contention and too many calls to check the job status. Use with care for both issues there is a remedy, which we will meet later!}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Configuration File}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{Snakemake} \texttt{resources} Section}
  \texttt{Snakemake} rules provide an additional \altverb{resource} section:
  \begin{lstlisting}[language=Python,style=Python]
rule <name>:
   ...
   resources:
      partition='parallel',
      mem_mb=1800,
      cpus_per_task=4
  \end{lstlisting}
  \hint{Note the \textbf{,}!}
  \pause
  \docs{You \emph{may} define \emph{any} resource keyword within any rule.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{The \texttt{Snakemake} \texttt{resources} Section - its Downside}
  \begin{alertblock}{Every Resource Spec needs a Change per Rule???}
   You might have noticed, this specification per rule is most untidy. \texttt{Snakemake}'s design principle is: ship workflows which run \emph{everywhere} \& \emph{every time}.
   \newline \pause
   Relax: Every bit we can specify:
   \begin{itemize}
    \item in a \texttt{Snakefile},
    \item on the command line,
    \item and re-usable in configuration files!
   \end{itemize}

  \end{alertblock}

\end{frame} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{The Configuration File}
  If observed closely you have seen this file:\newline
            {\tiny \DTsetlength{0.2em}{1em}{0.2em}{0.4pt}{.6pt}
\texttt{\$ tree}
\dirtree{%
.1 /.
.2 config.
.3 samples.yaml .
.2 {other stuff}.
}}
 \pause
 \docs{You can store a yaml file with \emph{your} workflow configuration -- which may be combined with the desinger's configuration.}
 \pause
 \warning{It is better to specify fully qualified paths to your data! The tilde is only there to make a point!}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Using the Configuration File}
  To point to the configuration file, you can add a flag, e.\,g.:
  \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake ... --configfile ./config/samples.yaml  
  \end{lstlisting}
  Yet, you have seen its contents?
  \begin{lstlisting}[language=Bash, style=Shell]
$ cat ./config/samples.yaml
path: '~/workflows/books'
limit: 10
  \end{lstlisting}
  \question{How do pick up resource parameters in out \texttt{Snakefile}?!}
\end{frame} 

\begin{frame}[fragile]
  \frametitle{\Interlude{Introducing Python's \texttt{os} Library}}
  Python has a library to provide functions to deal with operating systems, including file systems. Check out:
  \begin{lstlisting}[language=Python,style=Python]
>>> import os
>>> path = "~/workflows/books"
>>> os.realpath(path)
  \end{lstlisting}
  \pause
  Wait! Would this be an option to give a output path, too?
  \begin{lstlisting}[language=Python,style=Python,basicstyle=\footnotesize]
>>> input_path = os.realpath(path)
>>> output_path = os.path.join(os.path.dirname(input_path),
                               "results")
  \end{lstlisting}
  \task{Try \altverb{os.path.join('asdf', 'foo')} yourself. What do you observe? Use this output as input for \altverb{os.path.dirname()}. What do you observe?}
  \vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begingroup
\setbeamertemplate{footline}{}
\begin{frame}[fragile]
  \frametitle{Using the Configuration File - II}
  Within our \texttt{Snakefile} we can access our configuration as any Python dictionary:
  \begin{lstlisting}[language=Python,style=Python]
input_path = config["path"]
  \end{lstlisting}
  \hint{We know, its useless: if our \texttt{path} is a relative path, every derived path is relative to our current working directory!}
  \pause
  Luckily, \texttt{Snakefile}s are Python-Code:
  \begin{lstlisting}[language=Python,style=Python]
import os

input_path  = os.path.realpath(config['path'])
output_path = os.path.join(os.path.dirname(input_path),
                           "results")

DATS = glob_wildcards(os.path.join(input_path, 
                      "{book}.txt")).book
  \end{lstlisting}
\end{frame}
\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{A potential head of our Workflow}
  You will find this solution in your next template.
  \begin{lstlisting}[language=Python,style=Python, basicstyle=\small]
import os

input_path  = os.path.realpath(config['path'])
output_path = os.path.join('results', 
                  os.path.dirname(input_path))

DATS = glob_wildcards(os.path.join(input_path, 
                      "{book}.txt")).book

rule all:
    input: "results.txt"

...
  \end{lstlisting}
\end{frame}

\subsection{HPC Job Parametization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{HPC Job Parametization with Config Files}
  While we \emph{can} specify rule specific resoures on the command line with \altverb{--set-resources <rulename>:partition="parallel"} and so on, it is better to keep it in the config file for repeated use:
  \begin{lstlisting}[language=Python,style=Python]
set-resources:
    <rule name>:
        mem_per_cpu: 10MB
        partition: 10
        runtime: 10
        tasks: 2
  \end{lstlisting}
  \docs{This works for multiple rules. We will re-visit this during the course. You may refer to the \lhref{https://snakemake.readthedocs.io/en/stable/executing/cluster.html}{\texttt{Snakemake} cluster documentation} for details.}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Different Configurations!}
  \begin{columns}
    \begin{column}{0.5\textwidth}
        So, we have this layout:
              {\tiny \DTsetlength{0.2em}{1em}{0.2em}{0.4pt}{.6pt}
\texttt{\$ tree}
\dirtree{%
.1 /.
.2 config.
.3 samples.yaml.
.2 profile.
.3 config.yaml.
.2 {other stuff}.
}}
    \end{column}
    \begin{column}{0.5\textwidth}
      \question{Why keep the workflow parameterization and the cluster parameterization apart?}
      \pause
      \docs[Answer]{Workflow parameter is workflow specific, cluster parameterization is executor specific!}
    \end{column}
  \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{Using Different Configurations}
  Now we just have to employ these configurations:\newline
  \begin{onlyenv}<1| handout:1>
    We remember, that 
    \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake @--slurm@
    \end{lstlisting}
    will select the SLURM cluster executor.\vfill
  \end{onlyenv}
  \begin{onlyenv}<2| handout:1>
    If we add,
    \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake --slurm \
>  @--configfile@ <path to workflow config file>
    \end{lstlisting}
    we can select samples and specify workflow parameters.\vfill
  \end{onlyenv}
  \begin{onlyenv}<3| handout:1>
   Now we can simply add:
       \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake --slurm \
>  --configfile <path to workflow config file> \
>  @--profile@ <path to executor profile file> 
    \end{lstlisting}
    to select our execution parameters.\vfill
  \end{onlyenv}
  \begin{onlyenv}<4| handout:1>
   And finally:
       \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake --slurm \
>  --configfile <path to workflow config file> \
>  --profile <path to executor profile file> \
> @--default-resources@ \ 
>   slurm_account=<SLURM account> \
>   slurm_partition=<SLURM partition> 
> -j unlimited
    \end{lstlisting}
    For otherwise unspecified defaults.
    \vfill
  \end{onlyenv}
  \begin{onlyenv}<5| handout:1>
   And finally, finally:
       \begin{lstlisting}[language=Bash, style=Shell]
$ snakemake --slurm \
>  --configfile <path to workflow config file> \
>  --profile <path to executor profile file> \
> --default-resources \ 
>   slurm_account=<SLURM account> \
>   slurm_partition=<SLURM partition> \
> @-j@ unlimited
    \end{lstlisting}
    For the feast to begin with possibly many jobs being spawned.
    \vfill
  \end{onlyenv}
\end{frame}

