%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introducing Wildcards}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
    \frametitle{Outline}
    \begin{columns}[t]
        \begin{column}{.5\textwidth}
            \tableofcontents[sections={1-9},currentsection]
        \end{column}
        \begin{column}{.5\textwidth}
            \tableofcontents[sections={10-18},currentsection]
        \end{column}
    \end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{What is this about?}
   \question[Questions]{\begin{itemize}
                         \item The workflow still is pretty verbose, how can we be more concise?
                         \item How can the redundancy in a workflow be reduced?
                        \end{itemize}
                       }
   \docs[Objectives]{\begin{enumerate}
                      \item Use \texttt{Snakemake} wildcards to simplify our rules.
                      \item Output files are a product not only of input files but of the scripts or code that created the output files.
                     \end{enumerate}}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Better In-/Output}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Rule number One: Don't repeat Yourself!}

Our \texttt{Snakefile} has enormous redundancy: 
\begin{itemize}
 \item names of in-/output files are repeated
 \item rules for every in-/output
\end{itemize}
\docs{\texttt{Snakefile}s are a form of code and, in any code, repeated code can lead to problems (e.g. we rename a data file in one part of the \texttt{Snakefile} but forget to rename it elsewhere).}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Wildcards}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{output\}} Wildcard}
  Consider our last rule
  \begin{lstlisting}[language=Python,style=Python]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' abyss.dat isles.dat last.dat > results.txt'
  \end{lstlisting}
  We can replace the result name first with the wildcard \altverb{\{output\}}:
  \begin{lstlisting}[language=Python,style=Python]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' abyss.dat isles.dat last.dat > {output}'
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{input\}} Wildcard}
  Likewise, we may choose to replace our inputs:
  \begin{lstlisting}[language=Python,style=Python]
# generate summary table
rule zipf_test:
    input:  'abyss.dat', 'last.dat', 'isles.dat'
    output: 'results.txt'
    shell:  'python scripts/zipf_test.py' 
            ' {input} > {output}'
  \end{lstlisting}
  Here, \altverb{\{input\}} will contain the entire list of inputs!
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The \texttt{\{input\}} Wildcard - II}
  We have learned that
  \begin{lstlisting}[language=Python,style=Python]
rule <rulename>:
  input: <file1>, <file2>, ... <file_n>
  \end{lstlisting}
  translates to a list which we can access as
  \begin{lstlisting}[language=Python,style=Python]
  shell: 'cmd {input}'
  \end{lstlisting}
  As it is a list, we can access individual items by index, too. E.\,g.:
  \begin{lstlisting}[language=Python,style=Python]
  shell: 'cmd --reference {input[0} -i {input[1]}'
  \end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The  \texttt{\{input\}} Wildcard - III}
  So, \altverb{\{input\}}, can be a single item, a list (accessible by index) or named. For example:
  \begin{lstlisting}[language=Python,style=Python]
rule <rulename>:
  input:
    reference: <path to reference>
    forward:   <path to forward reads>
    reverse:   <path to reverse reads>
  # minimap2 is just an example
  shell: 'minimap2 {reference} {forward}' 
         ' {reverse} > {output}'
  \end{lstlisting}
  \pause
  \altverb{\{output\}} follows the same rules, so for both the options are:
  \begin{itemize}
   \item single item
   \item list (accessible by index)
   \item named access
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  We \emph{could} write:
  \begin{lstlisting}[language=Python,style=Python]
rule count_words:
    input:
        wc='scripts/wordcount.py',
        book='../books/{file}.txt'
    output: '{file}.dat'
    shell:  'python {input.wc} {input.book} {output}'
  \end{lstlisting}
  \explanation{\altverb{\{file\}} is another arbitrary wildcard, that we can use as a placeholder for any generic book to analyse. Note that we don’t have to use \emph{``file''} as the name of our wildcard — it can be anything we want! Condition: Only available for \altverb{input} and \altverb{output}, not for actions!}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  So, we had:
    \begin{lstlisting}[language=Python,style=Python]
  rule count_words:
    input:
        wc='scripts/wordcount.py',
        book='../books/{file}.txt'
    output: '{file}.dat'
    shell:  'python {input.wc} {input.book} {output}'   
    \end{lstlisting}
    \begin{block}{This rule can be interpreted as:}
``In order to build a file named \altverb{something.dat} (the output) find a file named \altverb{../books/something.txt} (the input) and run \altverb{wordcount.py input output}.''
  \end{block}
\end{frame}

\begingroup
\setbeamertemplate{footline}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{\HandsOn{Using the \texttt{\{input\}} and \texttt{\{output\}} wildcards!}}
  \begin{enumerate}
   \item Re-write the current workflow to be using the \altverb{\{input\}} and \altverb{\{output\}} wildcards. This only needs to be in the \altverb{shell} directive.
   \item Also, use the \altverb{\{file\}} wildcard to reduce the \altverb{count...} rules to just \altverb{count_words} for all inputs.
   \item For this, remember:
         \begin{lstlisting}[language=Python,style=Python]
rule ...:
    input: '../books/{file}.txt'
    output: '{file}.dat'
         \end{lstlisting}
         to be combined with the \altverb{\{input\}} and \altverb{\{output\}} wildcards in the \altverb{shell} directive.
  \end{enumerate}
  \hint{Refer to \texttt{04\_Snakefile} as the cloze text.}
  \vfill
\end{frame}
\endgroup


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
Our little exercise should produce this Workflow:
      \begin{lstlisting}[language=Python,style=Python, basicstyle=\tiny]
rule dats:
     input:
        'results.txt'

# delete everything so we can re-run things
rule clean:
    shell: 'rm -f *.dat'

rule count_words:
    input:  '../books/{file}.txt'
    output: '{file}.dat'
    shell:  'python scripts/wordcount.py -i {input} -o {output}'
    
# generate summary table
rule zipf_test:
    input: "abyss.dat", "isles.dat", "last.dat"
    output: 'results.txt'
    shell:  
        'scripts/zipf_test.py  {input} > {output}'
      \end{lstlisting}

\end{frame}
